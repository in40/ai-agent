"""
API Gateway for AI Agent System
Routes requests to appropriate services
"""
import os
import requests
from flask import Flask, request, jsonify, Response, render_template, send_from_directory
from flask_cors import CORS
import logging
from datetime import datetime
import json

# Import security components
from backend.security import require_permission, validate_input, Permission

# Initialize Flask app
app = Flask(__name__)
# Set maximum content length to 500MB to allow for multiple file uploads
app.config['MAX_CONTENT_LENGTH'] = 500 * 1024 * 1024  # 500MB

# Enable CORS for all routes
CORS(app)

# Initialize logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Service endpoints
AUTH_SERVICE_URL = os.getenv('AUTH_SERVICE_URL', 'http://localhost:5001')
AGENT_SERVICE_URL = os.getenv('AGENT_SERVICE_URL', 'http://localhost:5002')
RAG_SERVICE_URL = os.getenv('RAG_SERVICE_URL', 'http://localhost:5003')

# Web client directory
WEB_CLIENT_DIR = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))), 'web_client')


@app.route('/health', methods=['GET'])
def health_check():
    """Health check endpoint"""
    return jsonify({
        'status': 'healthy',
        'service': 'gateway',
        'timestamp': datetime.utcnow().isoformat(),
        'version': '0.5.0',
        'services': {
            'auth': AUTH_SERVICE_URL,
            'agent': AGENT_SERVICE_URL,
            'rag': RAG_SERVICE_URL
        }
    }), 200


@app.route('/', methods=['GET'])
def serve_web_client():
    """Serve the main web client interface"""
    try:
        # Try to serve index.html from the web client directory
        return send_from_directory(WEB_CLIENT_DIR, 'index.html')
    except FileNotFoundError:
        # If index.html doesn't exist, return a simple welcome message
        return '''
        <!DOCTYPE html>
        <html>
        <head>
            <title>AI Agent System</title>
            <style>
                body { font-family: Arial, sans-serif; text-align: center; padding: 50px; }
                .container { max-width: 600px; margin: 0 auto; }
            </style>
        </head>
        <body>
            <div class="container">
                <h1>Welcome to the AI Agent System</h1>
                <p>The microservices architecture is running.</p>
                <p>Available endpoints:</p>
                <ul style="text-align: left;">
                    <li><code>/health</code> - System health check</li>
                    <li><code>/auth/*</code> - Authentication endpoints</li>
                    <li><code>/api/agent/*</code> - Agent API endpoints</li>
                    <li><code>/api/rag/*</code> - RAG API endpoints</li>
                </ul>
                <p>For the web interface, ensure the web client files are in the correct directory.</p>
            </div>
        </body>
        </html>
        '''


@app.route('/<path:path>', methods=['GET'])
def serve_static(path):
    """Serve static files from the web client directory"""
    try:
        return send_from_directory(WEB_CLIENT_DIR, path)
    except FileNotFoundError:
        # If the file doesn't exist, serve the index.html for SPA routing
        return send_from_directory(WEB_CLIENT_DIR, 'index.html')


# Proxy routes to Auth Service
@app.route('/auth/<path:path>', methods=['GET', 'POST', 'PUT', 'DELETE'])
@app.route('/auth/', methods=['GET', 'POST', 'PUT', 'DELETE'])
@app.route('/auth', methods=['GET', 'POST', 'PUT', 'DELETE'])
def proxy_auth(path=''):
    """Proxy requests to the authentication service"""
    url = f"{AUTH_SERVICE_URL}/{path}"

    headers = {key: value for (key, value) in request.headers if key.lower() != 'host'}
    headers['Host'] = AUTH_SERVICE_URL.replace('http://', '').replace('https://', '')

    try:
        resp = requests.request(
            method=request.method,
            url=url,
            headers=headers,
            data=request.get_data(),
            cookies=request.cookies,
            allow_redirects=False,
            timeout=600  # Increased timeout to 10 minutes for AI model responses
        )

        excluded_headers = ['content-encoding', 'content-length', 'transfer-encoding', 'connection']
        headers = [(name, value) for (name, value) in resp.raw.headers.items()
                   if name.lower() not in excluded_headers]

        response = Response(resp.content, resp.status_code, headers)
        return response
    except Exception as e:
        logger.error(f"Auth service proxy error: {str(e)}")
        return jsonify({'error': 'Auth service unavailable'}), 503


# Proxy routes to Agent Service
@app.route('/agent/<path:path>', methods=['GET', 'POST', 'PUT', 'DELETE'])
@app.route('/agent/', methods=['GET', 'POST', 'PUT', 'DELETE'])
@app.route('/agent', methods=['GET', 'POST', 'PUT', 'DELETE'])
def proxy_agent(path=''):
    """Proxy requests to the agent service"""
    url = f"{AGENT_SERVICE_URL}/{path}"

    headers = {key: value for (key, value) in request.headers if key.lower() != 'host'}
    headers['Host'] = AGENT_SERVICE_URL.replace('http://', '').replace('https://', '')

    try:
        resp = requests.request(
            method=request.method,
            url=url,
            headers=headers,
            data=request.get_data(),
            cookies=request.cookies,
            allow_redirects=False,
            timeout=600  # Increased timeout to 10 minutes for AI model responses
        )

        excluded_headers = ['content-encoding', 'content-length', 'transfer-encoding', 'connection']
        headers = [(name, value) for (name, value) in resp.raw.headers.items()
                   if name.lower() not in excluded_headers]

        response = Response(resp.content, resp.status_code, headers)
        return response
    except Exception as e:
        logger.error(f"Agent service proxy error: {str(e)}")
        return jsonify({'error': 'Agent service unavailable'}), 503


# Proxy routes to RAG Service
@app.route('/rag/<path:path>', methods=['GET', 'POST', 'PUT', 'DELETE'])
@app.route('/rag/', methods=['GET', 'POST', 'PUT', 'DELETE'])
@app.route('/rag', methods=['GET', 'POST', 'PUT', 'DELETE'])
def proxy_rag(path=''):
    """Proxy requests to the RAG service"""
    url = f"{RAG_SERVICE_URL}/{path}"

    headers = {key: value for (key, value) in request.headers if key.lower() != 'host'}
    headers['Host'] = RAG_SERVICE_URL.replace('http://', '').replace('https://', '')

    try:
        resp = requests.request(
            method=request.method,
            url=url,
            headers=headers,
            data=request.get_data(),
            cookies=request.cookies,
            allow_redirects=False,
            timeout=600  # Increased timeout to 10 minutes for AI model responses
        )

        excluded_headers = ['content-encoding', 'content-length', 'transfer-encoding', 'connection']
        headers = [(name, value) for (name, value) in resp.raw.headers.items()
                   if name.lower() not in excluded_headers]

        response = Response(resp.content, resp.status_code, headers)
        return response
    except Exception as e:
        logger.error(f"RAG service proxy error: {str(e)}")
        return jsonify({'error': 'RAG service unavailable'}), 503


# Convenience routes that map to appropriate services
@app.route('/api/agent/query', methods=['POST'])
@require_permission(Permission.WRITE_AGENT)
def agent_query(current_user_id):
    """Convenience route for agent queries"""
    try:
        # Forward to agent service
        url = f"{AGENT_SERVICE_URL}/query"
        headers = {
            'Content-Type': 'application/json',
            'Authorization': request.headers.get('Authorization', '')
        }

        resp = requests.post(url, json=request.get_json(), headers=headers, timeout=600)  # Increased timeout to 10 minutes for AI model responses
        return Response(resp.content, resp.status_code, resp.headers.items())
    except Exception as e:
        logger.error(f"Agent query convenience route error: {str(e)}")
        return jsonify({'error': 'Agent service unavailable'}), 503


@app.route('/api/rag/query', methods=['POST'])
@require_permission(Permission.READ_RAG)
def rag_query(current_user_id):
    """Convenience route for RAG queries"""
    try:
        # Forward to RAG service
        url = f"{RAG_SERVICE_URL}/query"
        headers = {
            'Content-Type': 'application/json',
            'Authorization': request.headers.get('Authorization', '')
        }

        resp = requests.post(url, json=request.get_json(), headers=headers, timeout=600)  # Increased timeout to 10 minutes for AI model responses
        return Response(resp.content, resp.status_code, resp.headers.items())
    except Exception as e:
        logger.error(f"RAG query convenience route error: {str(e)}")
        return jsonify({'error': 'RAG service unavailable'}), 503


@app.route('/api/rag/ingest', methods=['POST'])
@require_permission(Permission.WRITE_RAG)
def rag_ingest(current_user_id):
    """Convenience route for RAG ingestion"""
    try:
        # Forward to RAG service
        url = f"{RAG_SERVICE_URL}/ingest"
        headers = {
            'Content-Type': 'application/json',
            'Authorization': request.headers.get('Authorization', '')
        }

        resp = requests.post(url, json=request.get_json(), headers=headers, timeout=600)  # Increased timeout to 10 minutes for AI model responses
        # Return the response from the RAG service with its original status code
        excluded_headers = ['content-encoding', 'content-length', 'transfer-encoding', 'connection']
        headers = [(name, value) for (name, value) in resp.raw.headers.items()
                   if name.lower() not in excluded_headers]
        response = Response(resp.content, resp.status_code, headers)
        return response
    except Exception as e:
        logger.error(f"RAG ingest convenience route error: {str(e)}")
        return jsonify({'error': 'RAG service unavailable'}), 503


@app.route('/api/rag/retrieve', methods=['POST'])
@require_permission(Permission.READ_RAG)
def rag_retrieve(current_user_id):
    """Convenience route for RAG retrieval"""
    try:
        # Forward to RAG service
        url = f"{RAG_SERVICE_URL}/retrieve"
        headers = {
            'Content-Type': 'application/json',
            'Authorization': request.headers.get('Authorization', '')
        }

        resp = requests.post(url, json=request.get_json(), headers=headers, timeout=600)  # Increased timeout to 10 minutes for AI model responses
        return Response(resp.content, resp.status_code, resp.headers.items())
    except Exception as e:
        logger.error(f"RAG retrieve convenience route error: {str(e)}")
        return jsonify({'error': 'RAG service unavailable'}), 503


@app.route('/api/rag/lookup', methods=['POST'])
@require_permission(Permission.READ_RAG)
def rag_lookup(current_user_id):
    """Convenience route for RAG lookup"""
    try:
        # Forward to RAG service
        url = f"{RAG_SERVICE_URL}/lookup"
        headers = {
            'Content-Type': 'application/json',
            'Authorization': request.headers.get('Authorization', '')
        }

        resp = requests.post(url, json=request.get_json(), headers=headers, timeout=600)  # Increased timeout to 10 minutes for AI model responses
        return Response(resp.content, resp.status_code, resp.headers.items())
    except Exception as e:
        logger.error(f"RAG lookup convenience route error: {str(e)}")
        return jsonify({'error': 'RAG service unavailable'}), 503


@app.route('/api/rag/upload', methods=['POST'])
@require_permission(Permission.WRITE_RAG)
def rag_upload(current_user_id):
    """Convenience route for RAG upload with robust error handling"""
    try:
        # Forward to RAG service
        url = f"{RAG_SERVICE_URL}/upload"

        # Handle multipart form data for file uploads
        files = []
        uploaded_filenames = []
        
        # Get all files from the request
        file_list = request.files.getlist('files')
        
        if not file_list:
            logger.warning("No files provided in upload request")
            return jsonify({
                'error': 'No files provided',
                'message': 'Please select at least one file to upload'
            }), 400
        
        # Process each file
        for i, file_storage in enumerate(file_list):
            if file_storage and file_storage.filename != '':
                try:
                    # Read the file content
                    file_content = file_storage.read()
                    if not file_content:
                        logger.warning(f"Empty file content for file: {file_storage.filename}")
                        continue
                    
                    # Get content type, default to application/octet-stream if not provided
                    content_type = file_storage.content_type or 'application/octet-stream'
                    
                    # Add to files list for forwarding
                    files.append(('files', (file_storage.filename, file_content, content_type)))
                    uploaded_filenames.append(file_storage.filename)
                    
                except Exception as e:
                    logger.error(f"Error processing file {file_storage.filename}: {str(e)}")
                    continue
        
        if not files:
            logger.warning("No valid files to upload after processing")
            return jsonify({
                'error': 'No valid files to upload',
                'message': 'All files were empty or could not be processed'
            }), 400
        
        # Prepare headers (excluding Content-Type which will be set by requests for multipart)
        forwarded_headers = {}
        for key, value in request.headers:
            # Skip headers that should not be forwarded
            if key.lower() in ['content-type', 'content-length', 'host', 'content-encoding']:
                continue
            forwarded_headers[key] = value
        
        # Add authorization header if present
        if 'Authorization' in request.headers:
            forwarded_headers['Authorization'] = request.headers['Authorization']
        else:
            logger.warning("No Authorization header found in request")
        
        try:
            # Make the POST request to RAG service with timeout (10 minutes)
            resp = requests.post(
                url, 
                files=files, 
                headers=forwarded_headers, 
                timeout=600
            )
            
            # Log successful upload
            logger.info(f"Successfully uploaded {len(files)} files to RAG service: {', '.join(uploaded_filenames)}")
            
            # Return the response from the RAG service with its original status code
            # Exclude certain headers that should not be forwarded back
            excluded_headers = ['content-encoding', 'content-length', 'transfer-encoding', 'connection', 'keep-alive']
            headers = [
                (name, value) for (name, value) in resp.raw.headers.items()
                if name.lower() not in excluded_headers
            ]
            
            return Response(resp.content, resp.status_code, headers)
            
        except requests.exceptions.RequestException as e:
            # Handle specific request exceptions
            error_msg = f"RAG service request failed: {str(e)}"
            logger.error(error_msg)
            if hasattr(e, 'response') and e.response is not None:
                logger.error(f"RAG service response: {e.response.text}")
            
            return jsonify({
                'error': 'RAG service unavailable',
                'message': 'Failed to connect to RAG service',
                'details': str(e)
            }), 503
            
        except Exception as e:
            # Handle other exceptions during the request
            logger.error(f"Unexpected error during RAG upload request: {str(e)}")
            import traceback
            logger.error(traceback.format_exc())
            return jsonify({
                'error': 'Internal server error',
                'message': 'An unexpected error occurred during file upload'
            }), 500
            
    except Exception as e:
        # Handle exceptions in the main try block
        logger.error(f"RAG upload convenience route error: {str(e)}")
        import traceback
        logger.error(traceback.format_exc())
        return jsonify({
            'error': 'RAG service unavailable',
            'message': 'Failed to process file upload request',
            'details': str(e)
        }), 503


@app.route('/api/rag/clear', methods=['POST'])
@require_permission(Permission.WRITE_RAG)
def rag_clear(current_user_id):
    """Convenience route for clearing all documents from RAG"""
    try:
        # Forward to RAG service
        url = f"{RAG_SERVICE_URL}/clear"
        headers = {
            'Content-Type': 'application/json',
            'Authorization': request.headers.get('Authorization', '')
        }

        resp = requests.post(url, json=request.get_json(), headers=headers, timeout=600)  # Increased timeout to 10 minutes for AI model responses
        # Return the response from the RAG service with its original status code
        excluded_headers = ['content-encoding', 'content-length', 'transfer-encoding', 'connection']
        headers = [(name, value) for (name, value) in resp.raw.headers.items()
                   if name.lower() not in excluded_headers]
        response = Response(resp.content, resp.status_code, headers)
        return response
    except Exception as e:
        logger.error(f"RAG clear convenience route error: {str(e)}")
        return jsonify({'error': 'RAG service unavailable'}), 503


@app.route('/api/rag/upload_progress/<session_id>', methods=['GET'])
@require_permission(Permission.WRITE_RAG)
def rag_upload_progress(current_user_id, session_id):
    """Convenience route for getting RAG upload progress"""
    try:
        # Forward to RAG service
        url = f"{RAG_SERVICE_URL}/upload_progress/{session_id}"
        headers = {
            'Authorization': request.headers.get('Authorization', '')
        }

        resp = requests.get(url, headers=headers, timeout=600)  # Increased timeout to 10 minutes for AI model responses
        # Return the response from the RAG service with its original status code
        excluded_headers = ['content-encoding', 'content-length', 'transfer-encoding', 'connection']
        headers = [(name, value) for (name, value) in resp.raw.headers.items()
                   if name.lower() not in excluded_headers]
        response = Response(resp.content, resp.status_code, headers)
        return response
    except Exception as e:
        logger.error(f"RAG upload progress convenience route error: {str(e)}")
        return jsonify({'error': 'RAG service unavailable'}), 503


@app.route('/api/rag/upload_with_progress', methods=['POST'])
@require_permission(Permission.WRITE_RAG)
def rag_upload_with_progress(current_user_id):
    """Convenience route for RAG upload with progress"""
    try:
        # Forward to RAG service
        url = f"{RAG_SERVICE_URL}/upload_with_progress"

        # Handle multipart form data for file uploads

        # Prepare files for forwarding - properly handle multiple files with same key
        files = []
        for i, file_storage in enumerate(request.files.getlist('files')):
            if file_storage and file_storage.filename != '':
                # Read the file content to avoid stream issues
                file_content = file_storage.read()
                # Ensure content_type is not None, use a default if needed
                content_type = file_storage.content_type or 'application/octet-stream'
                files.append(('files', (file_storage.filename, file_content, content_type)))

        # Prepare headers (excluding Content-Type which will be set by requests for multipart)
        forwarded_headers = {}
        for key, value in request.headers:
            if key.lower() not in ['content-type', 'content-length']:
                forwarded_headers[key] = value

        # Add authorization header
        forwarded_headers['Authorization'] = request.headers.get('Authorization', '')

        resp = requests.post(url, files=files, headers=forwarded_headers, timeout=600)  # 10 minute timeout for large uploads and processing
        return Response(resp.content, resp.status_code, resp.headers.items())
    except Exception as e:
        logger.error(f"RAG upload with progress convenience route error: {str(e)}")
        import traceback
        logger.error(traceback.format_exc())
        return jsonify({'error': 'RAG service unavailable'}), 503


@app.route('/api/rag/limits', methods=['GET'])
@require_permission(Permission.READ_RAG)
def rag_limits():
    """Convenience route for getting RAG upload limits"""
    try:
        # Forward to RAG service
        url = f"{RAG_SERVICE_URL}/limits"

        # Prepare headers
        forwarded_headers = {}
        for key, value in request.headers:
            if key.lower() not in ['content-type', 'content-length']:
                forwarded_headers[key] = value

        # Add authorization header
        forwarded_headers['Authorization'] = request.headers.get('Authorization', '')

        resp = requests.get(url, headers=forwarded_headers, timeout=30)
        return Response(resp.content, resp.status_code, resp.headers.items())
    except Exception as e:
        logger.error(f"RAG limits convenience route error: {str(e)}")
        import traceback
        logger.error(traceback.format_exc())
        return jsonify({'error': 'RAG service unavailable'}), 503

@app.route('/api/rag/limits', methods=['GET'])
@require_permission(Permission.READ_RAG)  # Use appropriate permission
def rag_limits(current_user_id):
    """Return upload limits for the RAG system"""
    try:
        # Check if the RAG service is available by making a test call
        # or return default values
        try:
            # Option 1: If you have a RAG service with limits endpoint
            url = f"{RAG_SERVICE_URL}/limits"
            forwarded_headers = {}
            for key, value in request.headers:
                if key.lower() not in ['content-type', 'content-length']:
                    forwarded_headers[key] = value
            forwarded_headers['Authorization'] = request.headers.get('Authorization', '')
            
            resp = requests.get(url, headers=forwarded_headers, timeout=10)
            
            if resp.status_code == 200:
                return Response(resp.content, resp.status_code, resp.headers.items())
            else:
                # If RAG service doesn't have limits, return defaults
                return get_default_limits()
                
        except requests.exceptions.RequestException:
            # RAG service unreachable, return default limits
            return get_default_limits()
            
    except Exception as e:
        logger.error(f"Error getting RAG limits: {str(e)}")
        import traceback
        logger.error(traceback.format_exc())
        return get_default_limits()

def get_default_limits():
    """Return default upload limits"""
    return jsonify({
        'max_files_per_upload': 100,
        'max_file_size_bytes': 104857600,  # 100MB
        'max_file_size_mb': 100,
        'max_total_size_bytes': 524288000,  # 500MB
        'max_total_size_mb': 500
    }), 200

@app.route('/api/auth/validate', methods=['POST'])
def auth_validate():
    """Convenience route for token validation"""
    try:
        # Forward to auth service
        url = f"{AUTH_SERVICE_URL}/validate"
        headers = {
            'Content-Type': 'application/json',
            'Authorization': request.headers.get('Authorization', '')
        }

        resp = requests.post(url, json=request.get_json(), headers=headers, timeout=600)  # Increased timeout to 10 minutes for AI model responses
        return Response(resp.content, resp.status_code, resp.headers.items())
    except Exception as e:
        logger.error(f"Auth validation convenience route error: {str(e)}")
        return jsonify({'error': 'Auth service unavailable'}), 503


if __name__ == '__main__':
    # Get port from environment variable or default to 5000
    port = int(os.getenv('GATEWAY_PORT', 5000))

    # Check if running in production mode
    if os.getenv('FLASK_ENV') == 'production':
        try:
            # Production: Use Gunicorn programmatically
            from gunicorn.app.base import BaseApplication

            class StandaloneApplication(BaseApplication):
                def __init__(self, app, options=None):
                    self.options = options or {}
                    self.application = app
                    super(StandaloneApplication, self).__init__()

                def load_config(self):
                    for key, value in self.options.items():
                        if key in self.cfg.settings and value is not None:
                            self.cfg.set(key.lower(), value)

                def load(self):
                    return self.application

            options = {
                'bind': f'0.0.0.0:{port}',
                'workers': 4,
                'worker_class': 'sync',
                'timeout': 600,  # 10 minutes to match our timeout configuration
                'keepalive': 10,
                'max_requests': 1000,
                'max_requests_jitter': 100,
                'preload_app': True,
                'accesslog': '-',
                'errorlog': '-',
            }
            StandaloneApplication(app, options).run()
        except Exception as e:
            print(f"Gunicorn error: {type(e).__name__}: {e}")
            print("Running in development mode instead...")
            app.run(host='0.0.0.0', port=port, debug=False)
    else:
        # Development: Use Flask's built-in server
        app.run(host='0.0.0.0', port=port, debug=False)
